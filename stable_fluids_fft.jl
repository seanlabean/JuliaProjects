#=
Dear reader:
This script is meant to be a learning process and environment for myself.
Heavily inspired by a Youtube tutorial by Machine Learning & Simulations:
https://www.youtube.com/watch?v=F7rWoxeGrko&list=LL&index=2
The code for which can be found here:
https://github.com/Ceyron/machine-learning-and-simulation/blob/main/english/simulation_scripts/stable_fluids_fft.jl

I am not setting out to improve this code, only understand it better.
Many comments are my own additions that function as a deeper 
explanation of the code's functionality.

This code utilizes some of Julia's special operations that allow force
conscise element-wise array manipulation as well as algorithms that operate
in-place which saves both time and space.

-Sean C Lewis
________________________________________________________
________________________________________________________

Solves the equations of incompressible fluid flow using 
'Stable Fluids' by Jos Stam. The incompressible Navier-Stokes equations
is solved by transforming to and from fourier-space using the
FFT to obtain super fast cartesian mesh simulations.

This works for the imcompressible Navier-Stokes equations:

momentum:           δu/δt + (u  ̇ ∇) u = - 1/ρ ∇ρ +ν∇²u +f 

Incompressibility:  ∇  ̇ u = u

u:  Velocity (2d vector)
p:  Pressure
f:  Forcing (here =0)
ν:  Kinematic Viscosity
ρ:  Density
t:  Time
∇:  Nabla operator (defining nonlinear convection, gradiant, and divergence)
∇²: Laplace operator

- - - -

Computational Domain:
A unit square domain with periodic boundary conditions on each edge
(= simulation on a torus)


  1 +-------------------------------------------------+
    |                                                 |
    |             *                      *            |
    |          *           *    *    *                |
0.8 |                                                 |
    |                                 *               |
    |     *       *                                   |
    |                      *     *                    |
0.6 |                                            *    |
    |      *                         <- <- <-         |
    |                             *  <- <- <-         |
    |     -> -> ->               *   <- <- <-         |
    |     -> -> ->    *                *         *    |
0.4 |     -> -> ->                                    |
    |                                                 |
    |      *            *             *               |
    |           *                             *       |
0.2 |                       *           *             |
    |                               *                 |
    |  *          *      *                 *       *  |
    |                            *                    |
  0 +-------------------------------------------------+
    0        0.2       0.4       0.6       0.8        1

Notes:
-> Streams are centered in y, slightly offset in x.
-> Streams are generated by two horizontal forcings in opposite directions.
-> Force magnitudes will be normal distribution, only applied in x direction.
-> Two fluid streams will "collide" with one another.

Solution Strategy:

-> Construct 2d computational domain where fluid points have 
   2d postion and velocity properties.

-> Start with zero velocity everywhere: u = [0, 0]

1. Add forces.

    w₁ = u + Δt f

2. Convect by self-advection (set the value at the current
   location to be the value at the position backtraced 
   on the streamline.) -> unconditionally stable.
   Classical implementation, essentially a semi-Lagrangian step.

   w₂ = w₁(p(x, -Δt))

3. Diffuse and Project in Fourier Domain.

   3.1 Forward Transformation into Fourier Domain.
       
       w₂ → w₃
   
   3.2 Diffuse by "low-pass filtering" (convolution
       is multiplication in the Fourier Domain). Here,
       we convolve with a gaussian to punish high wavenumbers.
       
       w₄ = exp(− k² ν Δt) w₃
   
   3.3 Compute the (pseudo-) pressure in the Fourier Domain
       by evaluating the divergence in the Fourier Domain.
       Multiply velocities with normalized wavenumbers.
       
       q = w₄ ⋅ k / ||k||₂
   
   3.4 Correct the velocities such that they are incompressible.
       Subtracting the gradient of pseudo pressure.
       
       w₅ = w₄ − q k / ||k||₂
   
   3.5 Inverse Transformation back into spatial domain.
       
       w₆ ← w₅

4. Repeat.

    k = [ kₓ, k_y ] are the spatial frequencies (= wavenumbers)

The Fourier Transformation implicitly prescribes the periodic
Boundary Conditions because FTs require such to be present.
=#
using FFTW
using Plots
using ProgressMeter
using Interpolations
using LinearAlgebra

N_POINTS = 250
KINEMATIC_VISCOSITY = 0.0001
TIME_STEP_LENGTH = 0.01
N_TIME_STEPS = 60

function backtrace!(
    backtraced_positions,
    original_positions,
    velocity_prev,
)
    """
    Preforms an Euler step backwards in time to recover previous positions.
    The ! notation has this function operate in place. Backtraced values are
    also clamped to be contrained to the computational domain.
    
    Backtraced values can (likely) land on a point within a cell where position 
    values are not defined (since they exist on vertecies only) so we will have
    to do some interpolation later.
    """
    # Euler step backwards in time
    backtraced_positions[:] = original_positions - TIME_STEP_LENGTH * velocity_prev
    # [:] overrides input values

    # Since we can possibly leave the computational domain, we need to clamp these values.
    clamp!(backtraced_positions, 0.0, 1.0)
end

function interpolate_positions!(
    field_interpolated,
    field,
    interval_x,
    interval_y,
    query_points_x,
    query_points_y,
)
    interpolator = LinearInterpolation(
        (interval_x, interval_y),
        field,
    )
    field_interpolated[:] = interpolator.(query_points_x, query_points_y)
end
function main()

    # building computational domain
    element_length = 1.0 / (N_POINTS - 1)
    x_interval = 0.0:element_length:1.0
    y_interval = 0.0:element_length:1.0

    # similar array generation to meshgrid in NumPy
    coordinates_x = [x for x in x_interval, y in y_interval]
    coordinates_y = [y for x in x_interval, y in y_interval]

    # use grid properties to generate 1d wavenumber
    wavenumbers_1d = fftfreq(N_POINTS) .* N_POINTS
    
    wavenumbers_x = [k_x for k_x in wavenumbers_1d, k_y in wavenumbers_1d]
    wavenumbers_y = [k_y for k_x in wavenumbers_1d, k_y in wavenumbers_1d]
    wavenumbers_norm = [norm([k_x, k_y]) for k_x in wavenumbers_1d, k_y in wavenumbers_1d]

    # decay expression and normalized components
    decay = exp.(- TIME_STEP_LENGTH .* KINEMATIC_VISCOSITY .* wavenumbers_norm.^2)

    # wavenumbers_norm could be 0, set it to 1.0 if that is ever the case
    wavenumbers_norm[iszero.(wavenumbers_norm)] .= 1.0
    normalized_wavenumbers_x = wavenumbers_x ./ wavenumbers_norm
    normalized_wavenumbers_y = wavenumbers_y ./ wavenumbers_norm

    # now define the forces
    # the .* operator is element-wise multiplication for multidimensional arrays.
    force_x = 100.0 .* (
        exp.( - 1.0 / (2 * 0.005) .* ((coordinates_x .- 0.2).^2 + (coordinates_y .- 0.45).^2))
        -
        exp.( - 1.0 / (2 * 0.005) .* ((coordinates_x .- 0.8).^2 + (coordinates_y .- 0.55).^2))
    )

    # preallocate all arrays (prev positions, current & prev velocities)
    backtraced_coordinates_x = zero(coordinates_x) # for our convection by self-advection
    backtraced_coordinates_y = zero(coordinates_y)

    velocity_x = zero(coordinates_x)
    velocity_y = zero(coordinates_y)

    velocity_x_prev = zero(velocity_x)
    velocity_y_prev = zero(velocity_y)

    velocity_x_fft = zero(velocity_x)
    velocity_y_fft = zero(velocity_y)
    pressure_fft = zero(coordinates_x)

    @showprogress "Timestepping ..." for iter in 1:N_TIME_STEPS
        # (1) Apply forces
        time_current = (iter - 1) * TIME_STEP_LENGTH
        pre_factor = max(1 - time_current, 0.0) # linear decay to forces.
        velocity_x_prev += TIME_STEP_LENGTH * pre_factor * force_x 

        # (2) Self-Advection by backtracing and interpolation
        backtrace!(backtraced_coordinates_x, coordinates_x, velocity_x_prev)
        backtrace!(backtraced_coordinates_y, coordinates_y, velocity_y_prev)

        # Need to interpolate these backtraced coordinates since we likely landed
        # somewhere other than a vertex.
        interpolate_positions!(
            velocity_x,
            velocity_x_prev,
            x_interval,
            y_interval,
            backtraced_coordinates_x,
            backtraced_coordinates_y,
        )
        interpolate_positions!(
            velocity_y,
            velocity_y_prev,
            x_interval,
            y_interval,
            backtraced_coordinates_x,
            backtraced_coordinates_y,
        )

        # (3.1) Transform into Fourier Domain
        velocity_x_fft = fft(velocity_x)
        velocity_y_fft = fft(velocity_y)

        # (3.2) Diffuse by low-pass filtering
        velocity_x_fft .*= decay
        velocity_y_fft .*= decay

        # (3.3) Compute Pseudo-Pressure by divergence in Fourier Domain
        pressure_fft = (
            velocity_x_fft .* normalized_wavenumbers_x
            +
            velocity_y_fft .* normalized_wavenumbers_y
        )

        # (3.4) Project the velocities to be incompressible
        velocity_x_fft -= pressure_fft .* normalized_wavenumbers_x
        velocity_y_fft -= pressure_fft .* normalized_wavenumbers_y

        # (3.5) Transform back into spatial domain
        velocity_x = real(ifft(velocity_x_fft))
        velocity_y = real(ifft(velocity_y_fft))

        # Advance in time
        velocity_x_prev = velocity_x
        velocity_y_prev = velocity_y

        # Visualize curl of fluid
        d_u__d_y = diff(velocity_x, dims=2)[2:end, :]
        d_v__d_x = diff(velocity_y, dims=1)[:, 2:end]
        curl = d_u__d_y - d_v__d_x
        display(heatmap(x_interval, y_interval, curl')) # c=:diverging_bkr_55_10_c35_n256))
    end



end

main()
